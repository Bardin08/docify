using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Linq;
using Docify.Core.Models;
using Docify.LLM.Models;

namespace Docify.LLM.Validation;

/// <summary>
/// Validates LLM-generated XML documentation for correctness and completeness.
/// </summary>
public partial class OutputValidator
{
    [GeneratedRegex(@"<(summary|param|returns|remarks|exception)(\s+[^>]*)?>.*?</\1>", RegexOptions.Singleline)]
    private static partial Regex XmlTagsRegex();

    /// <summary>
    /// Validates LLM-generated XML documentation against API context requirements.
    /// </summary>
    /// <param name="generatedXml">The XML documentation string generated by the LLM.</param>
    /// <param name="context">The API context containing signature information for validation.</param>
    /// <returns>A ValidationResult indicating whether the XML is valid and listing any issues found.</returns>
    public ValidationResult ValidateXmlDocumentation(string? generatedXml, ApiContext context)
    {
        ArgumentNullException.ThrowIfNull(context);

        // Handle empty or null response
        if (string.IsNullOrWhiteSpace(generatedXml))
            return ValidationResult.Invalid("LLM returned empty response");

        var issues = new List<string>();
        string? cleanedXml = null;

        // Try to extract XML tags first (handles mixed text with XML)
        var extractedXml = TryExtractXml(generatedXml);
        if (extractedXml != null && extractedXml != generatedXml)
        {
            // Found XML tags within non-XML text, use extracted version
            cleanedXml = extractedXml;
            generatedXml = extractedXml;
        }

        // Validate XML syntax
        try
        {
            _ = XDocument.Parse($"<root>{generatedXml}</root>");
        }
        catch (XmlException ex)
        {
            return ValidationResult.Invalid($"Invalid XML syntax: {ex.Message}");
        }

        // Validate required tags
        ValidateRequiredTags(generatedXml, context, issues);

        return issues.Count > 0
            ? ValidationResult.Invalid(issues)
            : ValidationResult.Valid(cleanedXml);
    }

    private static void ValidateRequiredTags(string generatedXml, ApiContext context, List<string> issues)
    {
        // Check for required <summary> tag (mandatory for all APIs)
        if (!generatedXml.Contains("<summary>", StringComparison.OrdinalIgnoreCase))
            issues.Add("Missing required <summary> tag");

        // Check for <param> tags if API has parameters
        if (context.ParameterTypes.Count > 0)
            foreach (var param in context.ParameterTypes)
            {
                // Extract parameter name (format: "TypeName paramName")
                var parts = param.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 2)
                {
                    var paramName = parts[^1]; // Last part is parameter name
                    if (!generatedXml.Contains($"<param name=\"{paramName}\"", StringComparison.OrdinalIgnoreCase))
                        issues.Add($"Missing required <param name=\"{paramName}\"> tag");
                }
            }

        // Check for <returns> tag if API returns non-void
        if (!string.IsNullOrWhiteSpace(context.ReturnType) &&
            context.ReturnType != "void" &&
            !generatedXml.Contains("<returns>", StringComparison.OrdinalIgnoreCase))
            issues.Add("Missing required <returns> tag");
    }

    private static string? TryExtractXml(string response)
    {
        var matches = XmlTagsRegex().Matches(response);
        if (matches.Count == 0)
            return null;

        // Combine all matched XML tags
        var extractedXml = string.Join(Environment.NewLine, matches.Select(m => m.Value));
        return extractedXml;
    }
}
